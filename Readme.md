# PyRedis - A Simplified Redis Clone in Python

## Introduction

This project is an educational exercise to build a simplified, Redis-like key-value store server and client using Python. It demonstrates core concepts such as:

*   In-memory data storage (dictionaries, deques)
*   TCP socket programming for client-server communication
*   Handling multiple client connections using threading
*   Implementing basic Redis commands (Strings, Lists, Hashes)
*   Basic key expiration
*   Simple data persistence using Python's `pickle` module

**Disclaimer:** This project is intended solely for learning purposes. It is **not** a production-ready replacement for the real Redis. It lacks the performance optimizations, robustness, extensive feature set, advanced concurrency control, and security considerations of the official Redis implementation.

## Features

The server implements a subset of Redis commands:

*   **String Commands:**
    *   `SET key value [EX milliseconds]` - Set key to hold string value, optionally with expiry.
    *   `GET key` - Get the value of a key.
*   **Key Commands:**
    *   `DEL key [key ...]` - Delete one or more keys.
    *   `EXPIRE key seconds` - Set a timeout on a key (in seconds).
    *   `TTL key` - Get the remaining time to live for a key.
*   **List Commands:**
    *   `LPUSH key element [element ...]` - Prepend one or multiple elements to a list.
    *   `RPUSH key element [element ...]` - Append one or multiple elements to a list.
    *   `LRANGE key start stop` - Get a range of elements from a list.
*   **Hash Commands:**
    *   `HSET key field value` - Set the string value of a hash field.
    *   `HGET key field` - Get the value of a hash field.
    *   `HDEL key field [field ...]` - Delete one or more hash fields.
*   **Server Commands:**
    *   `PING` - Returns "PONG", used to test connection.
    *   `SAVE` - Saves the current dataset to disk (`pyredis_dump.pkl`).
    *   `QUIT` - Closes the connection.
    *   `COMMAND` - (Basic) Lists available commands.

## Tech Stack

*   **Python 3**
*   Standard Libraries:
    *   `socket` (Networking)
    *   `threading` (Concurrency)
    *   `pickle` (Persistence)
    *   `os` (File system interaction)
    *   `time` (Expiry handling)
    *   `collections.deque` (Efficient list implementation)
*   Testing: `pytest` (Optional, for running the test suite)

## Project Structure

```
.
├── redis_store.py          # Core in-memory data store logic (handles command execution)
├── redis_server.py         # TCP server that listens for clients and uses the store
├── redis_client.py         # Simple interactive command-line client
├── test_redis_store.py     # Pytest tests for the data store logic
├── pyredis_dump.pkl        # (Generated by SAVE) Persistence file
└── README.md               # This file
```

## How to Run

### Prerequisites

1.  **Python 3:** Ensure you have Python 3 installed on your system.
2.  **Code:** Download or clone the project files (`redis_store.py`, `redis_server.py`, `redis_client.py`, and optionally `test_redis_store.py`).
3.  **Pytest (Optional):** If you want to run the tests, install pytest:
    ```bash
    pip install pytest
    ```

### 1. Start the Server

Open a terminal in the project directory and run:

```bash
python redis_server.py
```

*   The server will start listening on `127.0.0.1` (localhost) on port `6380`.
*   You should see output like: `[Server] PyRedis server listening on 127.0.0.1:6380`.
*   If a `pyredis_dump.pkl` file exists in the directory from a previous run, the server will attempt to load the data from it.

### 2. Run the Client

Open a *second* terminal in the same project directory and run:

```bash
python redis_client.py
```

*   The client will connect to the server running on `127.0.0.1:6380`.
*   You will see a prompt like: `127.0.0.1:6380>`.
*   You can now type PyRedis commands (e.g., `SET name Johan`, `GET name`, `LPUSH mylist git`, `LRANGE mylist 0 -1`, `PING`) and press Enter. The server's response will be printed.
*   Type `QUIT` to disconnect the client.

*Optional Client Arguments:* You can specify a different host and port when starting the client:
`python redis_client.py <host> <port>`
Example: `python redis_client.py 192.168.1.100 6380`

### 3. Run Tests (Optional)

If you have `pytest` installed, open a terminal in the project directory and run:

```bash
pytest
```

*   This will automatically discover and run the tests defined in `test_redis_store.py`, verifying the core logic of the data store commands.

## Persistence

*   The server supports basic snapshot persistence.
*   When a client sends the `SAVE` command, the server serializes its current in-memory data (keys, values, and expiration timestamps) into the file `pyredis_dump.pkl` using Python's `pickle` module.
*   When the server starts, it checks for the existence of `pyredis_dump.pkl`. If found, it loads the data back into memory, restoring the state from the last `SAVE`.
*   **Note:** The `SAVE` command currently blocks the server while writing to disk.

## Limitations

*   **Educational Use Only:** Not production ready.
*   **Performance:** Significantly slower than real Redis due to Python overhead and basic concurrency model (single global lock).
*   **Protocol:** Uses a simple newline-terminated string protocol, not the official RESP (REdis Serialization Protocol). This limits functionality (e.g., handling binary data correctly) and interoperability.
*   **Concurrency:** Uses a basic `threading.Lock` around the entire data store, limiting true parallel command execution.
*   **Persistence:** `SAVE` is blocking. `pickle` format is Python-specific and potentially insecure if the dump file source is untrusted. No incremental persistence (like AOF).
*   **Features:** Only implements a small subset of Redis commands and data types. Missing Sets, Sorted Sets, Streams, Pub/Sub, transactions, Lua scripting, etc.
*   **Memory Management:** No memory limits or eviction policies (like LRU).
*   **Error Handling:** Basic error handling; not all edge cases are covered robustly.
*   **Networking:** Basic socket handling; less resilient to network issues than production servers.
*   **No Clustering/Replication:** Operates as a single standalone instance.
